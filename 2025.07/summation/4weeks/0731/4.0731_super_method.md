# 0731 super 메서드

- 메서드 해석 순서(MRO)에 따라 현재 클래스의 부모 클래스의 메서드나 속성에 접근할 수 있게 해주는 내장 함수

### 특징

- 단순히 부모클래스의 메서드 호출 하기 위한 용도 뿐만 아니라 다중 상속이 있을때도 올바른 순서(MRO)에 따라 사위 클랴스의 메서드를 찾아 실행하기 위해 super()를 사용

### 단일 상속

```py


# super를 사용하지 않았을 때
class Person:
    def __init__(self, name, age, number, email):
        self.name = name
        self.age = age
        self.number = number
        self.email = email


class Student(Person):
    def __init__(self, name, age, number, email, student_id):
        self.name = name
        self.age = age
        self.number = number
        self.email = email
        self.student_id = student_id

```

> super를 사용하지 않으면 일일이 부모클래스의 인스턴스를 다 입력해줘야함

```py
# super를 사용했을 때
class Person:
    def __init__(self, name, age, number, email):
        self.name = name
        self.age = age
        self.number = number
        self.email = email


class Student(Person):
    def __init__(self, name, age, number, email, student_id):
        # super()를 통해 Person의 __init__ 메서드 호출
        super().__init__(name, age, number, email)
        self.student_id = student_id

```

> 여기에선 `super().__init__(name, age, number, email)`을 호출하여 부모 클래스인 Person 에 생성자 메서드를 호출

### 다중 상속

```py
# 다중 상속
class ParentA:
    def __init__(self):
        super().__init__()
        self.value_a = 'ParentA'

    def show_value(self):
        print(f'Value from ParentA: {self.value_a}')


class ParentB:
    def __init__(self):
        self.value_b = 'ParentB'

    def show_value(self):
        print(f'Value from ParentB: {self.value_b}')


class Child(ParentA, ParentB):
    def __init__(self):
        super().__init__()  # ParentA 클래스의 __init__ 메서드 호출
        self.value_c = 'Child'

    def show_value(self):
        super().show_value()  # ParentA 클래스의 show_value 메서드 호출

        print(f'Value from Child: {self.value_c}')


child = Child()
child.show_value()

Value from ParentA: ParentA
Value from Child: Child


print(child.value_c)  # Child
print(child.value_a)  # ParentA
print(
    child.value_b
)  # AttributeError: 'Child' object has no attribute 'value_b'

```

### <ParentA에 super().**init**()를 추가하면?>

그 다음으로 ParentB의 **init**가 실행되어 value_b도 초기화할 수 있음
그러면 print(child.value_b)는 ParentB를 출력하게 됨

print(child.value_b) # ParentB

### <Child 클래스의 MRO>

Child -> ParentA -> ParentB

super()는 단순히 “직계 부모 클래스를 가리킨다”가 아니라,
MRO 순서를 기반으로 “현재 클래스의 다음 순서” 클래스(또는 메서드)를 가리킴

따라서 ParentA에서 super()를 부르면 MRO상 다음 클래스인 ParentB.**init**()가 호출됨

#### 1.1 Child 클래스의 인스턴스를 생성할 때 일어나는 일

    1.	child = Child() 호출 시, Child.__init__()가 실행
    2.	Child.__init__() 내부에서 super().__init__()를 호출
        - 여기서 Child의 super()는 MRO에 의해 ParentA의 __init__()를 가리킴
    3.	ParentA.__init__()로 진입

#### 1.2. ParentA.**init**() 내부

    1.	ParentA.__init__()에는 다시 super().__init__()가 있음

    2.	ParentA를 기준으로 MRO에서 “다음 클래스”는 ParentB, 따라서 ParentA의 super().__init__()는 ParentB.__init__() 호출

    3.	ParentB.__init__()가 실행되면서 self.value_b = 'ParentB'가 설정됨

    4.	ParentB.__init__()가 종료된 후, 다시 ParentA.__init__()로 돌아와 self.value_a = 'ParentA'가 설정됨

    5.	ParentA.__init__() 종료 후, 다시 Child.__init__()로 돌아감

    6.	마지막으로 Child.__init__() 내에서 self.value_c = 'Child'가 설정되고 종료

### 1.3 결과적으로 child 인스턴스는 value_a, value_b, value_c 세 속성을 모두 갖게 됨

    - child.value_a → 'ParentA'

    - child.value_b → 'ParentB'

    - child.value_c → 'Child'

### MRO관련 순서 확인 방법

- mro(), `__mro__` 를 출력하여 확인 가능

```py
class A:
    def __init__(self):
        print('A Constructor')


class B(A):
    def __init__(self):
        super().__init__()
        print('B Constructor')


class C(A):
    def __init__(self):
        super().__init__()
        print('C Constructor')


class D(B, C):
    def __init__(self):
        super().__init__()
        print('D Constructor')


# [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
print(D.mro())

# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
print(D.__mro__)

```

> 여기에서 MRO 알고리즘을 활용하여 참조의 순서를 확인 할 수 있다.
