
# 🧠 0728 깊은 복사(Deep Copy)

> **깊은 복사란?**

* 객체의 **모든 수준의 요소를 새로운 메모리에 복사**하는 방식
* 내부에 있는 **중첩된 객체까지 모두 새로운 객체로 복사**
* 원본 객체와 복사 객체가 완전히 독립됨

---

## ✅ 특징 정리

| 항목    | 설명                           |
| ----- | ---------------------------- |
| 복사 대상 | 객체의 모든 요소(내부 리스트, 딕셔너리 등 포함) |
| 복사 결과 | 완전히 새로운 객체 (중첩된 객체도 새롭게 생성)  |
| 독립성   | 원본 수정 시 복사본에 영향 없음, 반대도 마찬가지 |
| 모듈    | `copy.deepcopy()` 사용 필요      |

---

## ✅ 문법

```python
import copy

new_object = copy.deepcopy(original_object)
```

---

## ✅ 예제 1: 리스트 내부에 리스트가 있는 경우

```python
import copy

a = [1, 2, [3, 4, 5]]
b = copy.deepcopy(a)

b[2][1] = 100

print(a)  # [1, 2, [3, 4, 5]]
print(b)  # [1, 2, [3, 100, 5]]
print(f'a[2]와 b[2]가 같은 객체인가? {a[2] is b[2]}')  # False
```

* `a[2]`와 `b[2]`는 서로 **다른 객체**입니다.

---

## ✅ 예제 2: 딕셔너리 중첩 객체

```python
import copy

original = {'a': [1, 2, 3], 'b': {'c': 4, 'd': [5, 6]}}
copied = copy.deepcopy(original)

copied['a'][1] = 100
copied['b']['d'][0] = 500

print(f'원본: {original}')  
# {'a': [1, 2, 3], 'b': {'c': 4, 'd': [5, 6]}}

print(f'복사본: {copied}')  
# {'a': [1, 100, 3], 'b': {'c': 4, 'd': [500, 6]}}

print(f"original['b']와 copied['b']가 같은 객체인가? {original['b'] is copied['b']}")  
# False
```

---

## ✅ 시각화 요약

* 깊은 복사를 통해 \*\*모든 객체(프레임, 내부 리스트/딕셔너리)\*\*가 독립적으로 메모리에 새로 생성됨
* `a → [1, 2, [3, 4]]`와 `b → [1, 2, [100, 4]]`가 각각 독립 구조를 가지게 됨

---

## 📌 TIP: 깊은 복사 실수 주의

* 가변 객체를 얕은 복사할 경우 참조 공유로 인해 **예기치 않은 데이터 변경**이 발생할 수 있음
* 중첩된 구조를 완전히 분리하려면 반드시 **`deepcopy()`** 사용

---

✅ **시험 포인트 정리**

* `copy.deepcopy()`의 동작 원리와 예제 코드 숙지
* 얕은 복사와 깊은 복사의 차이 구분
* `is` 연산자를 통한 참조 비교 이해


---

## ✅ 비교 포인트 (얕은 복사 vs 깊은 복사)

| 항목    | 얕은 복사                      | 깊은 복사             |
| ----- | -------------------------- | ----------------- |
| 복사 수준 | 최상위 요소만                    | 중첩 요소까지 전체 복사     |
| 중첩 객체 | 기존 객체 참조                   | 새로운 객체 생성         |
| 원본 영향 | 내부 수정 시 영향 있음              | 완전 독립             |
| 예시 함수 | `[:]`, `.copy()`, `list()` | `copy.deepcopy()` |

---

시험 대비로는 특히 다음을 꼭 기억하세요:

* `[:]`, `.copy()`, `list()`는 **얕은 복사**임
* 중첩 리스트 구조에서는 참조 공유로 인해 **원본과 복사본 모두 변경됨**
* 내부 구조까지 완전히 분리하려면 **`deepcopy()` 사용**



##### © 2025 Migong0311 and SSAFY. All rights reserved.
