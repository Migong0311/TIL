# 0729 set 

- 고유한 항목들의 정렬되지 않은 컬렉션 (해시 테이블 사용 데이터 저장)

- set는 값이 추가되어도 원본 값과 똑같이 정렬이 안됨 매번 다름


| 메서드                  | 설명                                                  |
| -------------------- | --------------------------------------------------- |
| `s.add(x)`           | 세트 `s`에 항목 `x`를 **추가**. **이미 `x`가 있다면 변화 없음**       |
| `s.update(iterable)` | 세트 `s`에 다른 iterable 요소를 **추가**                      |
| `s.clear()`          | 세트 `s`의 **모든 항목을 제거**                               |
| `s.remove(x)`        | 세트 `s`에서 항목 `x`를 **제거**. **항목이 없을 경우 Key error 발생** |
| `s.pop()`            | 세트 `s`에서 임의의 항목을 **반환하고, 해당 항목을 제거**                |
| `s.discard(x)`       | 세트 `s`에서 항목 `x`를 **제거**                             |


## **`s.add(x)`**

- set에 x를 추가

```py
# add
my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.add('d')
print(my_set) # {'a', 1, 2, 3, 'd', 'c', 'b'}

my_set.add('d')
print(my_set)

```

> 그러나 set는 해쉬 테이블에 저장이되어 해쉬의 버켓 위치에 따라 순서가 달라지기때문에 출력이 임의로 됨





## **`s.remove(x)`**

- 세트에서 항목 x를 **`제거`** , 항목 x가 없을 경우 `**keyerror**`

```py
# remove
my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.remove(2)
print(my_set)
# my_set.remove(10)  # KeyError: 10
```
> 여기에서 10은 my_set에 없기 때문에 에러 발생

### .update(iterable)

- 세트에 다른 iterable 요소를 추가

```py
# update
my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.update(range(6))
print(my_set)  # {0, 1, 2, 3, 4, 5, 'c', 'a', 'b'} // 출력값 보장 x
```
> 이것 역시 순서는 임의적임 
> 그리고 update엔 range 뿐만 아니라 iterable 객체면 뭐든 가능

### .clear()

- 세트의 모든 항목을 제거

```py
#  clear
my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.clear()
print(my_set)  # set()
```

### .pop()

- 세트에서 **`임의의`** 요소를 제거하고 **`반환`**

```py
# pop
my_set = {'a', 'b', 'c', 1, 2, 3}
element = my_set.pop()  # random은 아님
print(element)
print(my_set)

```
> 무작위가 아님 실제로 출력을 해보면 2,3은 거의 안되는걸 알 수 있음

### .discard(x)

- set s 에서 항목 x를 제거 `remove()`와 달리 에러 없음

```py
# discard
my_set = {'a', 'b', 'c', 1, 2, 3}
my_set.discard(2) # {1, 3, 'b', 'a', 'c'}
print(my_set)
my_set.discard(10)
```
> 10은 없는 수이지만 오류 발생 안함

### reference

- 세트의 집합 메서드

```py
# 집합 메서드
set1 = {0, 1, 2, 3, 4}
set2 = {1, 3, 5, 7, 9}
set3 = {0, 1}

print(set1.difference(set2))  # {0, 2, 4}
print(set1.intersection(set2))  # {1, 3}
print(set1.issubset(set2))  # False
print(set3.issubset(set1))  # True
print(set1.issuperset(set2))  # False
print(set1.union(set2))  # {0, 1, 2, 3, 4, 5, 7, 9
```

| 메서드                       | 설명                                                | 연산자            |
| ------------------------- | ------------------------------------------------- | -------------- |
| `set1.difference(set2)`   | `set1`에는 있지만 `set2`에는 없는 항목으로 새로운 **세트를 생성 후 반환** | `set1 - set2`  |
| `set1.intersection(set2)` | `set1`과 `set2` 모두에 **포함된 항목들로 세트를 생성 후 반환**       | `set1 & set2`  |
| `set1.issubset(set2)`     | `set1`의 **모든 항목이 `set2`에 들어있으면** `True` 반환        | `set1 <= set2` |
| `set1.issuperset(set2)`   | `set1`이 `set2`의 **모든 항목을 포함하고 있다면** `True` 반환     | `set1 >= set2` |
| `set1.union(set2)`        | `set1`, `set2` **또는 둘 다 포함된 항목들로 세트를 생성 후 반환**    | `set1 \| set2` |

##### © 2025 Migong0311 and SSAFY. All rights reserved.

