#### 1. 다음 중 상속을 사용하는 주된 이유로 옳은 것은?

1. 기존 클래스의 속성과 메서드를 재사용하여 코드 중복을 줄이기 위해
2. 함수 호출 속도를 빠르게 하기 위해
3. 직접 변수를 통해 데이터 접근을 간편하게 하기 위해
4. 파이썬 인터프리터의 메모리 사용량을 최소화하기 위해

---

#### 2. 다음 중 `super()` 키워드를 사용하는 주된 이유로 옳은 것은?

a) 부모 클래스의 메서드를 호출하기 위해
b) 새로운 클래스를 만들기 위해
c) 예외를 처리하기 위해
d) 클래스를 다중 상속하지 않도록 막기 위해

---

#### 3. `"hello" = 3 # SyntaxError: cannot assign to literal`를 실행할 때 발생하는 에러의 원인은?

a) 문자열과 숫자를 더하려고 시도했기 때문에
b) 문자열을 변수 이름으로 사용했기 때문에
c) 문자열에 값을 할당하려고 했기 때문에
d) 변수 선언을 하지 않고 바로 출력하려고 했기 때문에

---

#### 4. 다음 중 파이썬의 내장 예외가 아닌 것은?

a) `ValueError`
b) `IndexError`
c) `ZeroDivisionError`
d) `SyntaxError`

---

#### 5. 다음 코드의 실행 결과는?

```python
class Animal:
    def move(self):
        print("동물이 움직입니다.")

class Bird(Animal):
    def move(self):
        print("새가 날아갑니다.")

b = Bird()
b.move()
```

---

#### 6. 다음 중 `super()`에 대한 설명으로 옳지 않은 것은?

a) `super()`는 명시적 클래스 이름이나 인스턴스를 인자로 넘기지 않아도 동작한다.
b) `super()`는 다중 상속 시 MRO를 따라 다음 클래스를 자동으로 찾아 호출한다.
c) `super()`로 반환된 객체는 부모 클래스의 메서드를 호출할 때 인스턴스를 자동으로 바인딩한다.
d) `@staticmethod`로 정의된 메서드 안에서도 `super()`를 사용할 수 있다.

---

#### 7. 다음 코드 실행 시 어떤 예외가 발생하는지 고르시오.

```python
def divide(a, b):
    return a / b

result = divide(10, 0)
```

a) `ValueError`
b) `ZeroDivisionError`
c) `TypeError`
d) `IndexError`

---

#### 8. 다음 코드 실행 시 출력 결과로 옳은 것은?

```python
try:
    print("A")
except ValueError:
    print("B")
else:
    print("C")
finally:
    print("D")
```

a) A
b) A C
c) A C D
d) A B D

---

#### 9. 다음 중 EAFP와 LBYL의 설명이 올바르게 매칭된 것은?

a) EAFP는 사전 검사를 통해 안전을 확인하고, LBYL은 시도 후 예외를 처리한다.
b) EAFP는 시도 후 예외를 처리하는 방식이며, LBYL은 사전 검사를 통해 문제 발생을 방지하는 방식이다.
c) EAFP는 코드 실행 속도를 높이기 위한 최적화 기법이며, LBYL은 디버깅을 쉽게 하기 위한 방식이다.
d) EAFP와 LBYL은 같은 방식으로, 단순히 명칭만 다른 예외 처리 스타일이다.

---

#### 10. 다음 중 예외 발생 여부와 관계없이 항상 실행되는 예외 처리 블록 키워드는?

a) `try`
b) `except`
c) `else`
d) `finally`

> 🔗 [정답 및 해설 보기 (90페이지)](https://edu.ssafy.com/data/upload_files/crossUpload/openLrn/ebook/unzip/A2025072511055464500/index.html)
