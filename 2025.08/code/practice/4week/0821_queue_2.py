from collections import deque  # 큐(Queue) 연산을 위해 collections의 deque 사용

# 2차원 격자에서의 인접 정점(상/하/좌/우) 이동을 위한 방향 벡터
di = [-1, 1, 0, 0]  # 행(row) 변화량: 위로 -1, 아래로 +1
dj = [0, 0, -1, 1]  # 열(col) 변화량: 왼쪽 -1, 오른쪽 +1

N = 7  # 미로의 한 변 길이 (N x N 격자)

# (예시1) 벽(1), 빈길(0), 목표(99)가 섞인 미로
maze = [[0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 1, 1, 1, 0],
        [0, 1, 0, 1, 0, 1, 0],
        [0, 0, 0, 1, 0, 0, 0],
        [1, 0, 1, 1, 1, 0, 1],
        [1, 0, 1, 99, 0, 0, 0],
        [0, 0, 1, 1, 1, 0, 1]]

# (예시2) 전부 빈길(0)로 설정된 미로
# ⚠️ 아래 대입으로 인해 위의 미로 설정이 '덮어쓰기' 됩니다.
#    따라서 현재 상태에선 목표(99)가 존재하지 않아 탐색 결과는 "실패"가 됩니다.
maze = [[0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0]]


def where_am_i(i, j, visited):
    """
    디버깅/시각화를 위해 현재 방문 위치(i,j)와 방문/거리 정보(visited)를 출력합니다.
    현재 좌표는 '★'로 표시, 나머지는 해당 칸의 방문 거리(0이면 미방문)를 출력.
    """
    for ni in range(N):                    # 모든 행에 대해
        for nj in range(N):                # 모든 열에 대해
            if (i, j) == (ni, nj):         # 현재 내가 있는 좌표면
                print("★", end=" ")        # 별표로 표시
            else:
                print(visited[ni][nj], end=" ")  # 방문 거리 출력(0은 미방문)
        print()                            # 행 개행
    print("=================")               # 구분선


def is_valid(i, j):
    """격자 범위(0 ~ N-1) 안에 있는지 검사하는 유효성 함수"""
    return 0 <= i < N and 0 <= j < N


def bfs(si, sj):
    """
    BFS(너비 우선 탐색)로 미로에서 시작점 (si, sj)로부터
    목표 값(99)을 찾는 최단 거리를 계산합니다.
    - 벽(1)은 이동 불가
    - 빈길(0) 및 목표(99)는 이동 가능
    - visited에는 '시작점으로부터의 거리'를 저장
    """
    visited = [[0] * N for _ in range(N)]  # 방문/거리 정보 2차원 배열(0은 미방문)
    q = deque()                             # BFS용 큐 생성
    q.append((si, sj))                      # 시작 좌표를 큐에 넣고
    # visited[si][sj]는 0(시작점까지의 거리 0)

    while q:                                # 큐가 빌 때까지(탐색할 좌표가 남아있는 동안)
        i, j = q.popleft()                  # 현재 탐색할 좌표를 큐에서 꺼냄

        where_am_i(i, j, visited)           # (옵션) 현재 위치/방문상태 시각화

        # 현재 위치가 목표(99)인지 검사
        if maze[i][j] == 99:
            print(f"탈출 : ({i},{j}), 거리 : {visited[i][j]}")
            return visited[i][j]            # 시작점에서 목표까지 최단 거리 반환

        # 현재 위치 (i, j)의 상/하/좌/우 이웃을 확인
        for d in range(4):
            ni = i + di[d]                  # 다음 행 좌표
            nj = j + dj[d]                  # 다음 열 좌표

            # 이동 가능 조건:
            # 1) 격자 내 유효한 좌표
            # 2) 아직 방문하지 않은 칸
            # 3) 벽(1)이 아닌 칸 (0 또는 99면 이동 가능)
            if is_valid(ni, nj) and not visited[ni][nj] and maze[ni][nj] != 1:
                q.append((ni, nj))                          # 다음 방문 후보로 큐에 추가
                visited[ni][nj] = visited[i][j] + 1         # 시작점으로부터 거리 갱신(부모 + 1)

    # 큐가 빌 때까지 목표를 찾지 못한 경우(도달 불가)
    print("실패")
    return -1


# 시작점 (3, 3)에서 BFS 실행
# ⚠️ 현재 maze는 전부 0이므로 99(목표)가 없어 "실패"가 출력됩니다.
#    테스트하려면 예: maze[5][3] = 99 처럼 목표를 하나 지정한 뒤 실행하세요.
bfs(3, 3)
