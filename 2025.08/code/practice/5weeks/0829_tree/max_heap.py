# 최대 힙으로 사용할 배열
heap = [0] * 11  # -> 1번 인덱스부터 쓰기 위해 크기 11로 생성 (heap[0]은 미사용)

# 마지막으로 넣은원소의 위치를 기억
last = 0  # -> 힙에 현재 들어있는 마지막 원소의 인덱스(노드 수와 동일). 비어 있으면 0


# 삽입
def enq(item):  # -> 최대 힙에 원소 item을 삽입하는 함수 (sift-up 수행)
    global last  # -> 전역 변수 last를 내부에서 갱신하기 위해 선언
    # item을 맨 마지막 자리에 추가
    # 맨마지막 위치 : last + 1
    last += 1  # -> 새로운 노드가 추가되므로 마지막 위치를 1 증가
    heap[last] = item  # -> 배열의 last 위치에 새 원소 저장
    # (주의) 용량 체크는 생략됨. last가 len(heap)-1을 초과하면 IndexError 발생 가능

    # 일단 넣어봤는데 님 자리가 맞음?
    # 최대힙 : 부모 > 자식
    # item 의 크기와 부모 노드의 크기를 비교해서 교환
    child = last  # -> 현재 삽입된 노드의 위치(아래에서 위로 끌어올릴 대상)
    # 완전이진트리 이므로 부모 = 자식 / 2
    parent = child // 2  # -> 현재 노드의 부모 인덱스(루트의 부모는 0으로 표시)

    # child에 있는 값과 parent 에 있는 값을 비교
    # 부모 노드가 존재하고 부모노드보다 자식이 크면
    # 자리를 계속 교환
    while parent != 0 and heap[child] > heap[parent]:  # -> 부모가 있고, 힙 성질 위반(부모 < 자식)이면 교환 반복
        heap[child], heap[parent] = heap[parent], heap[child]  # -> 부모-자식 자리 바꾸기
        child = parent  # -> 한 레벨 위로 올라감(이전 부모가 새 child가 됨)
        parent = child // 2  # -> 새 child의 부모를 다시 계산하여 다음 비교 준비
    # -> 루프 종료 시점: 부모가 없거나(루트 도달) 부모 >= 자식이 되어 최대 힙 성질 만족


# 삭제
def deq():  # -> 최대 힙에서 루트 원소를 삭제하고 반환하는 함수 (sift-down 수행)
    global last  # -> last를 갱신해야 하므로 전역 사용
    # 루트 노드 삭제 전에 기억
    root = heap[1]  # -> 반환해야 할 최댓값(루트)을 임시로 저장

    # 마지막 위치에 있는 원소를 루트 자리로 땡겨요
    heap[1] = heap[last]  # -> 트리의 공백을 메우기 위해 마지막 원소를 루트로 이동
    # 원소 제거 했으니 마지막 원소 위치도 -1
    last -= 1  # -> 노드 수 감소. 사실상 마지막 원소는 논리적으로 제거됨(값은 남아 있어도 무시)

    # 일단 루트 자리에 마지막 원소 땡겼는데
    # 그게 맞나
    # 부모 > 자식 조건을 만족하도록 아래로 내려가며(자식과) 교환 필요

    # 완전이진트리에서 부모와 자식의 인덱스
    p = 1  # -> 현재 부모 인덱스(루트부터 시작)
    c = p * 2  # left_c  -> 왼쪽 자식 인덱스(기본 비교 대상). 오른쪽 자식은 c+1

    # 자식이 2명 있으면 그중에 큰 자식과 비교하여
    # 부모와 자리 교환을 반복
    while c <= last:  # -> 왼쪽 자식이 존재하는 동안(자식 하나라도 있으면 진행)
        # c+1은 자식번호
        # 이 오른쪽 자식이 존재하는지
        # 오른쪽 자식이 왼쪽보다 큰가
        if c + 1 <= last and heap[c] < heap[c + 1]:  # -> 오른쪽 자식이 존재하고 값이 더 크면
            # 그렇다면 비교 자식은 오른쪽으로
            c += 1  # -> 더 큰 자식을 c로 사용하여 부모와 비교
        # 자식이 부모보다 큰지 확인하고 교환
        if heap[p] < heap[c]:  # -> 힙 성질 위반(부모 < 자식)이면
            heap[p], heap[c] = heap[c], heap[p]  # -> 부모와 더 큰 자식 교환
            p = c  # 자식이 새로운 부모  -> 내려간 위치를 새 부모로 갱신
            c *= 2  # 새로운 부모 기준 왼쪽 자식  -> 다음 비교를 위해 왼쪽 자식 인덱스 계산
        else:
            # 부모가 자식보다 크면 맞는 자리, 자리바꾸기 중단
            break  # -> 더 이상 내려갈 필요 없음. 최대 힙 성질 만족
    # 처음에 기억한 삭제 루트 리턴
    return root  # -> 삭제한 최댓값 반환


lst = [6, 5, 4, 1, 3, 2, 9, 8, 7, 10]  # -> 힙에 삽입할 테스트 데이터(10개, 임의 순서)
for i in range(10):  # -> 리스트의 모든 값을 힙에 삽입
    enq(lst[i])  # -> 삽입 시마다 sift-up 수행하여 최대 힙 유지

print(heap)  # -> 내부 배열 상태 확인용 출력(1번 인덱스부터가 힙의 실제 데이터)

for i in range(10):  # -> 힙에서 10번 삭제하여 내림차순으로 값이 나오는지 확인
    print(deq(), end=',')  # -> deq의 반환값을 출력. 최대 힙이므로 매번 현재 최댓값이 출력됨
