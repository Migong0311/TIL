# 부분집합

- 어떤 집합의 공집합과 자기자신을 포함한 모든 부분
> [!TIP]
> 구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 수는 2^n개이다.

### backtracking 으로 부분집합

# 1) 핵심 개념 한줄 요약

* 크기 N인 배열 `arr`의 부분집합 개수는 **2^N**개입니다.
* 길이 N의 비트배열 `bit`를 두고 `bit[i]==1`이면 `arr[i]`를 포함, `0`이면 제외로 해석합니다.
* 결국 \*\*이진 선택(포함/미포함)\*\*을 깊이 N까지 내려가며 모두 탐색하면 파워셋이 완성됩니다.

---

# 2) 동작 흐름(Backtracking 템플릿)

* 깊이 `idx`는 현재 결정할 원소의 인덱스입니다.
* 매 단계에서 두 가지 선택을 합니다.

  1. `bit[idx] = 0` -> `arr[idx]`를 부분집합에 넣지 않음 -> 다음 idx로
  2. `bit[idx] = 1` -> `arr[idx]`를 부분집합에 넣음 -> 다음 idx로
* `idx == N`이 되면 하나의 부분집합 결정 완료 -> 출력 또는 수집
* 이 과정은 **이진 트리** 탐색과 같고, 전체 경우의 수가 2^N입니다.

간단 트레이스 예시 (`arr=[1,2,3]`)

```
idx=0: 1 제외 -> idx=1
         └─ idx=1: 2 제외 -> idx=2
                     └─ idx=2: 3 제외 -> {} 확정
                     └─ idx=2: 3 포함 -> {3} 확정
       1 포함 -> idx=1
         └─ idx=1: 2 제외 -> idx=2
                     └─ 3 제외 -> {1} 확정
                     └─ 3 포함 -> {1,3} 확정
         └─ idx=1: 2 포함 -> idx=2
                     └─ 3 제외 -> {1,2} 확정
                     └─ 3 포함 -> {1,2,3} 확정
```

---

# 3) 비트표로 보는 예시 (`arr = [1,2,3]`)

| bit | 부분집합    |
| --- | ------- |
| 000 | {}      |
| 001 | {3}     |
| 010 | {2}     |
| 011 | {2,3}   |
| 100 | {1}     |
| 101 | {1,3}   |
| 110 | {1,2}   |
| 111 | {1,2,3} |

* 위 표에서 `bit`는 `idx=0`이 최상위 비트라고 가정했습니다.
* 실제 구현에선 인덱스 기준이나 비트 순서를 어떻게 잡든 **일관성**만 유지하면 됩니다.

---

# 4) 코드 예시 1: 재귀 Backtracking 방식

> 주석은 핵심만 넣었습니다. 출력 순서는 선택 순서에 따라 달라질 수 있습니다.

```python
# 입력 배열
arr = [1, 2, 3]
N = len(arr)

# 결과 담을 리스트
result = []

# 현재 선택 상태를 담을 비트배열(0/1)
bit = [0] * N

def backtrack(idx, path):
    # 기저조건: 모든 원소에 대해 포함/제외 결정을 마침
    if idx == N:
        result.append(path[:])          # 현재 부분집합 기록
        return

    # 1) 현재 원소 제외
    bit[idx] = 0                        # 포함 안함 표시
    backtrack(idx + 1, path)            # 다음 인덱스로

    # 2) 현재 원소 포함
    bit[idx] = 1                        # 포함 표시
    path.append(arr[idx])               # 값 추가
    backtrack(idx + 1, path)            # 다음 인덱스로
    path.pop()                          # 백트래킹 복구

# 실행
backtrack(0, [])
print(result)   # 모든 부분집합
```

시간복잡도 -> 전체 경우의 수 2^N, 각 경우에 리스트 복사나 출력이 있어 **O(N·2^N)**
공간복잡도 -> 재귀 깊이 N과 경로 저장 공간 **O(N)**

---

# 5) 코드 예시 2: 비트마스크 반복 방식

> 이 방식은 백트래킹 없이 정수의 이진 표현으로 포함 여부를 판정합니다.

```python
arr = [1, 2, 3]
N = len(arr)

all_subsets = []

# mask는 0부터 (1<<N)-1 까지
for mask in range(1 << N):
    subset = []
    # 각 비트를 검사하여 포함 여부 결정
    for i in range(N):
        if mask & (1 << i):        # i번째 비트가 1이면 포함
            subset.append(arr[i])
    all_subsets.append(subset)

print(all_subsets)
```

* 장점 -> 구현이 매우 간단, 반복문만으로 가능
* 단점 -> 부분집합을 특정 순서대로 뽑고 싶을 때는 순서 제어가 필요

---

# 6) 자주 나오는 포인트

* **출력 순서**가 채점에 중요하면 기준을 명확히 잡아야 합니다.

  * 예: 인덱스 오름차순으로 돌리면 `{}` -> `{1}` -> `{2}` …처럼 정렬된 패턴 유지 가능
* **중복 원소가 있는 배열**이면 같은 부분집합이 여러 번 생성될 수 있습니다.

  * 필요 시 정렬 후 같은 값을 가진 인덱스를 건너뛰는 가지치기 로직 추가
* **합 제한, 원소 개수 제한** 같은 조건이 있으면

  * 백트래킹에서 조건을 만족하지 않으면 **조기 종료(Pruning)** 를 걸면 효율이 좋아집니다.


