# 이진 트리 표현 2

## 1. 부모 번호 인덱스로 자식 번호 저장하기

부모 노드 `p`의 **첫째 자식**은 `c1[p]`, **둘째 자식**은 `c2[p]`에 기록합니다.
간선 정보가 `(부모 p, 자식 c)`로 N개 들어온다고 가정합니다.

### 예시 트리

```
1
├─ 2
└─ 3
   ├─ 4
   └─ 5
```

간선: (1,2), (1,3), (3,4), (3,5)

### 배열 상태

* c1\[1] = 2, c2\[1] = 3
* c1\[3] = 4, c2\[3] = 5
* 나머지는 0

### 파이썬 코드

```python
# 부모 번호 인덱스로 자식 번호 저장
def build_children(n, edges):
    """
    n: 노드 개수(1..n)
    edges: [(p, c), ...]
    return: c1, c2 배열 (크기 n+1, 0은 사용 안 함)
    """
    c1 = [0] * (n + 1)  # 첫째 자식
    c2 = [0] * (n + 1)  # 둘째 자식
    for p, c in edges:
        if c1[p] == 0:
            c1[p] = c
        else:
            c2[p] = c
    return c1, c2

# 사용 예시
n = 5
edges = [(1,2), (1,3), (3,4), (3,5)]
c1, c2 = build_children(n, edges)
print("c1:", c1)  # c1: [0, 2, 0, 4, 0, 0]
print("c2:", c2)  # c2: [0, 3, 0, 5, 0, 0]
```

---

## 2. 자식 번호 인덱스로 부모 번호 저장하기

이번엔 반대로, **자식 c의 부모**를 `par[c]`에 기록합니다.

### 파이썬 코드

```python
# 자식 번호 인덱스로 부모 번호 저장
def build_parent(n, edges):
    """
    n: 노드 개수(1..n)
    edges: [(p, c), ...]
    return: par 배열 (크기 n+1), par[root]는 0
    """
    par = [0] * (n + 1)
    for p, c in edges:
        par[c] = p
    return par

# 사용 예시
n = 5
edges = [(1,2), (1,3), (3,4), (3,5)]
par = build_parent(n, edges)
print("par:", par)  # par: [0, 0, 1, 1, 3, 3]
```

---

## 3. 루트 찾기와 조상(Ancestor) 찾기

* **루트**: 부모가 없는 노드 → `par[x] == 0`
* **조상**: 어떤 노드에서 부모를 따라 올라가며 만나는 노드들

### 파이썬 코드

```python
def find_root(par):
    """ par 배열에서 루트 노드(부모가 0인 노드)를 찾아 반환 """
    for v in range(1, len(par)):
        if par[v] == 0:
            return v
    return None

def ancestors(node, par):
    """ node의 조상들을 위로 올라가며 리스트에 담아 반환 (루트 포함) """
    res = []
    c = node
    while par[c] != 0:
        c = par[c]
        res.append(c)
    return res  # 위쪽 방향으로 저장됨

# 사용 예시
par = [0, 0, 1, 1, 3, 3]  # 위 예시
root = find_root(par)
print("root:", root)              # root: 1
print("ancestors(5):", ancestors(5, par))  # [3, 1]
```

---

## 4. 배열로 표현한 이진트리의 단점

완전 이진트리는 배열로 표현하기 편하지만,

* **사용하지 않는 인덱스가 생겨 메모리 낭비**가 발생할 수 있습니다.
* **중간 삽입/삭제**가 어렵고 비효율적입니다.

> 그래서 일반 이진트리는 보통 **링크드 노드(left, right)** 구조로 표현합니다.

---

## 5. 연결 리스트(링크드 노드)로 이진트리 표현

각 노드가 `left`와 `right` 포인터를 가진다고 생각하면 됩니다.

### 파이썬 코드 – 노드 정의와 간단한 트리 구성

```python
class Node:
    def __init__(self, data, left=None, right=None):
        self.data  = data
        self.left  = left
        self.right = right

# 트리 만들기 (위 예시와 동일한 형태)
#     1
#    / \
#   2   3
#      / \
#     4   5
n2 = Node(2)
n4 = Node(4)
n5 = Node(5)
n3 = Node(3, n4, n5)
root = Node(1, n2, n3)
```

### 순회(Traversal) – 전위, 중위, 후위

```python
def preorder(node, visit):
    if node is None: return
    visit(node.data)          # V
    preorder(node.left, visit)  # L
    preorder(node.right, visit) # R

def inorder(node, visit):
    if node is None: return
    inorder(node.left, visit)   # L
    visit(node.data)            # V
    inorder(node.right, visit)  # R

def postorder(node, visit):
    if node is None: return
    postorder(node.left, visit)  # L
    postorder(node.right, visit) # R
    visit(node.data)             # V

# 사용 예시
print("preorder:", end=" ")
preorder(root, lambda x: print(x, end=" "))
print("\ninorder: ", end=" ")
inorder(root,  lambda x: print(x, end=" "))
print("\npostorder:", end=" ")
postorder(root, lambda x: print(x, end=" "))
print()
```

---

## 6. 완전 이진트리도 연결리스트로 만들 수 있나?

네, 가능합니다. 다만 완전 이진트리는 인덱스 규칙(부모 i → 왼쪽 2i, 오른쪽 2i+1)이 딱 맞으니 **배열 표현이 더 간편**합니다.
연결리스트 표현은 **삽입·삭제가 잦을 때** 유리합니다.

---

## 7. 수식 트리(Expression Tree)

**연산자**는 내부노드, **피연산자**는 잎노드가 됩니다.

예시 수식:

* 중위 표기: `A / B * C + D * E`
* 후위 표기: `A B / C * D E * +`
* 전위 표기: `+ * / A B C * D E`

### 후위 표기 → 수식 트리 만들기

```python
class ENode:
    def __init__(self, val, left=None, right=None):
        self.val   = val
        self.left  = left
        self.right = right

def build_expr_tree_from_postfix(tokens):
    """
    tokens: 후위 표기 리스트 예) ["A","B","/","C","*","D","E","*","+"]
    규칙: 피연산자는 스택 push, 연산자는 두 개 pop해서 좌우 자식으로 연결 후 push
    """
    stack = []
    ops = set(["+","-","*","/"])
    for tk in tokens:
        if tk not in ops:
            stack.append(ENode(tk))
        else:
            right = stack.pop()
            left  = stack.pop()
            stack.append(ENode(tk, left, right))
    return stack[-1]  # 루트

def inorder_expr(node):
    if node is None: return ""
    if node.left is None and node.right is None:
        return str(node.val)
    # 괄호로 그룹화
    return "(" + inorder_expr(node.left) + " " + str(node.val) + " " + inorder_expr(node.right) + ")"

def preorder_expr(node):
    if node is None: return ""
    return str(node.val) + " " + preorder_expr(node.left) + preorder_expr(node.right)

def postorder_expr(node):
    if node is None: return ""
    return postorder_expr(node.left) + postorder_expr(node.right) + str(node.val) + " "

# 사용 예시
postfix = ["A","B","/","C","*","D","E","*","+"]
eroot = build_expr_tree_from_postfix(postfix)
print("중위 :", inorder_expr(eroot))    # ((A / B) * C) + (D * E)
print("전위 :", preorder_expr(eroot))   # + * / A B C * D E
print("후위 :", postorder_expr(eroot))  # A B / C * D E * +
```

### 수식 트리 평가(숫자 대입)

```python
def eval_expr(node, env):
    """
    env: 변수 → 값 dict 예) {"A":8, "B":4, "C":3, "D":2, "E":5}
    연산자: + - * /  (실수 나눗셈)
    """
    if node.left is None and node.right is None:
        # 리프는 피연산자
        if isinstance(node.val, (int, float)):
            return node.val
        return float(env[node.val])
    op = node.val
    lv = eval_expr(node.left, env)
    rv = eval_expr(node.right, env)
    if op == "+": return lv + rv
    if op == "-": return lv - rv
    if op == "*": return lv * rv
    if op == "/": return lv / rv
    raise ValueError("unknown op")

# 사용 예시
env = {"A": 8, "B": 4, "C": 3, "D": 2, "E": 5}
print("평가 값:", eval_expr(eroot, env))  # ((8/4)*3) + (2*5) = 6 + 10 = 16
```

---

## 8. 한 번에 복습 포인트

* **부모 → 자식**: `c1[p]`, `c2[p]`
* **자식 → 부모**: `par[c]`
* **루트**: `par[v] == 0`
* **조상 찾기**: `par`를 따라 위로 이동
* **연결 트리**: `Node(data, left, right)`
* **순회**: 전위(VLR), 중위(LVR), 후위(LRV)
* **수식 트리**: 후위 표기 → 스택으로 트리 구성 → 순회로 표기 변환 및 평가

