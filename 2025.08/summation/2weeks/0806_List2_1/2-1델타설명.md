
## 🔍 핵심 개념: 델타 배열 (delta array)

2차원 배열에서 현재 위치 `(i, j)`를 기준으로 **상하좌우 인접한 칸**을 방문하려면, 각 방향에 따라 `(i, j)`의 변화량을 이용해야 합니다.

그 변화량을 배열로 정리한 것이 바로:

```
di[] = [ 0,  1,  0, -1 ]
dj[] = [ 1,  0, -1,  0 ]
```

* 이때, 각 인덱스는 방향을 의미합니다:

  * `k=0`: 오른쪽 → `(i, j+1)`
  * `k=1`: 아래 → `(i+1, j)`
  * `k=2`: 왼쪽 → `(i, j-1)`
  * `k=3`: 위 → `(i-1, j)`

---

## 🔁 델타 탐색 알고리즘

```python
for k in range(4):  # 방향 0 ~ 3
    ni = i + di[k]  # 인접한 행
    nj = j + dj[k]  # 인접한 열
```

위 코드는 현재 칸 `(i, j)`에서 네 방향을 차례로 탐색하는 구조입니다.

---

## 📦 이미지 속 요소 해석

### 1. 가운데 (i, j)

* 기준이 되는 셀 (현재 위치)

### 2. 상하좌우 방향

* 그림 중앙에서 화살표가 향하는 네 칸이 각각 인접한 칸이고,
* 각 칸에 **델타 변화량**이 적혀 있습니다:

  * 오른쪽 → `i+0, j+1` (즉, j값만 +1)
  * 아래 → `i+1, j+0`
  * 왼쪽 → `i+0, j-1`
  * 위 → `i-1, j+0`

### 3. 오른쪽 코드

* `di`, `dj` 배열 선언
* `for k in range(4)` 루프로 상하좌우를 탐색
* `(ni, nj)`에 다음 인접 칸 좌표 계산

---

## ✅ 델타 배열의 장점

1. **코드 간결화**: if문 없이 4방향 탐색을 쉽게 구현
2. **유연성**: 8방향, 대각선 등도 쉽게 확장 가능

   ```python
   # 8방향 탐색 예시
   di = [-1, -1, -1,  0, 1, 1, 1, 0]
   dj = [-1,  0,  1,  1, 1, 0, -1, -1]
   ```

---

## 💡 실제 예시

```python
for k in range(4):
    ni = i + di[k]
    nj = j + dj[k]
    
    # 배열의 범위 안에 있는지 확인하고 접근
    if 0 <= ni < N and 0 <= nj < M:
        print("인접 값:", arr[ni][nj])
```

* `N`, `M`은 배열의 크기
* `arr[ni][nj]`는 인접한 칸에 접근한 결과

