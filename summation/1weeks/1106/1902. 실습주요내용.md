네, Django의 1:N (일대다) 관계, 즉 \*\*외래 키(Foreign Key)\*\*를 사용할 때 겪으셨던 문제들과 해결 과정을 중심으로 핵심 지식을 요약해 드릴게요.

## Django 1:N (외래 키) 관계 핵심 요약

`Author`(1)와 `Book`(N) 모델 관계를 기준으로 설명합니다.

-----

### 1\. (핵심) `IntegrityError: NOT NULL constraint failed` 오류의 이해와 해결

이 오류는 \*\*"Book 모델을 저장하려는데, 필수 필드인 `author_id`가 비어있습니다"\*\*라는 뜻입니다. `Book`은 `Author` 없이는 존재할 수 없기(NOT NULL) 때문입니다.

이 문제는 `ModelForm`에서 `author` 필드를 `exclude` (요구사항: "저자 객체는 사용자가 직접 선택하지 않도록")했을 때 발생합니다. `request.POST`에는 책 제목, 내용 등만 있고 '누가' 썼는지에 대한 `author` 정보가 없기 때문입니다.

**💡 해결책: `commit=False` 패턴**

`form.save()`를 바로 호출하지 않고, DB에 저장하기 직전에 누락된 `author` 객체를 수동으로 할당(주입)합니다.

```python
# views.py - create 함수

def create(request, author_pk): # 1. URL로부터 '누구'의 책인지(author_pk) 받음
    
    # 2. 책을 쓸 저자 객체를 DB에서 조회
    author = get_object_or_404(Author, pk=author_pk)

    if request.method == 'POST':
        form = BookForm(request.POST)
        if form.is_valid():
            
            # 3. DB 저장을 잠시 보류 (메모리에만 객체 생성)
            book = form.save(commit=False) 
            
            # 4. (★핵심★) 누락된 author 필드에 조회해둔 저자 객체를 할당
            book.author = author
            
            # 5. 모든 정보가 채워졌으므로 DB에 최종 저장
            book.save() 
            
            return redirect('libraries:detail', author.pk)
    ...
```

-----

### 2\. URL 설계를 통한 '부모(1)' 객체 특정

`create` 뷰가 `author_pk`를 받을 수 있었던 것은 URL을 그렇게 설계했기 때문입니다. 이는 \*\*"특정 저자(1)에 종속된 책(N)을 생성한다"\*\*는 관계를 URL에 명확히 표현하는 RESTful 방식입니다.

  * `urls.py`
    ```python
    # <int:author_pk> 변수가 views.py의 create 함수로 전달됨
    path('libraries/<int:author_pk>/books/create/', views.create, name='create')
    ```
  * `views.py`
    ```python
    # URL의 <int:author_pk>를 인자로 받음
    def create(request, author_pk):
        ...
    ```
  * `detail.html` (요청)
    ```html
    <form action="{% url 'libraries:create' author.pk %}" method="POST">
    ```
  * **참고:** 처음에 겪으신 `unexpected keyword argument 'author_pk'` 오류는 `def create(request):`처럼 `author_pk`를 인자로 받지 않아서 발생한 문제입니다.

-----

### 3\. 관계 데이터 조회 (정참조와 역참조)

외래 키가 설정되면 Django ORM은 양방향으로 객체를 조회할 수 있게 해줍니다.

**A. 정참조 (N → 1): 자식(Book)에서 부모(Author) 조회**

  * `book.author`처럼 모델의 필드 이름을 그대로 사용합니다.
  * **예시:** `book_item.author.name` (책 객체에서 저자 이름 접근)

**B. 역참조 (1 → N): 부모(Author)에서 자식(Book) 목록 조회**

  * `[부모객체].[자식모델명]_set.all()` (기본) 또는 `[부모객체].[related_name].all()`
  * `detail` 뷰에서 저자의 모든 책을 가져올 때 사용합니다.
    ```python
    # views.py - detail 함수
    def detail(request, author_pk):
        author = get_object_or_404(Author, pk=author_pk)
        
        # 'author'가 가진 모든 'Book' 객체를 역참조로 가져옴
        books = author.book_set.all() 
        
        context = {
            'author': author,
            'books': books, # 템플릿에 전달
            ...
        }
    ```
  * `detail.html`
    ```html
    {% for book_item in books %}
      <p>* 제목 : {{ book_item.title }}</p>
    {% endfor %}
    ```

